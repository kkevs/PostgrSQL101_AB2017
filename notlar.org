Merhaba sevgili Postgresciler ğŸ™‚

PostgreSQL 101 eÄŸitiminden Ã¶ÄŸrendiklerimi size anlatacaÄŸÄ±m. BaÅŸlamadan Ã¶nce AB2017 nedir acaba diyen arkadaÅŸlara ufacÄ±k bir aÃ§Ä±klama -> Akademik BiliÅŸim, Ä°nternet Teknolojileri DerneÄŸi (Ä°NETD) tarafÄ±ndan dÃ¼zenlenen; akademik ortamlardaki bilgi teknolojileri konusunda Ã§alÄ±ÅŸan ilgili gruplarÄ± bir araya getirerek, bilgi teknolojileri altyapÄ±sÄ±, kullanÄ±mÄ±, eÄŸitimi ve Ã¼retimini tÃ¼m boyutlarÄ±yla tanÄ±tmayÄ±, tartÄ±ÅŸmayÄ±, tecrÃ¼beleri paylaÅŸmayÄ± ve ortak politikalar oluÅŸturmaya yardÄ±mcÄ± olmayÄ± amaÃ§layan ulusal bir konferanstÄ±r.4 gÃ¼nlÃ¼k postgreSQL 101 eÄŸitimi aldÄ±m. DÃ¶rt gÃ¼nlÃ¼k eÄŸitimi bÃ¶lÃ¼mlere ayÄ±rarak anlatacaÄŸÄ±m birinci bÃ¶lÃ¼me baÅŸlayalÄ±m ğŸ™‚

PostgreSQL, veritabanlarÄ± iÃ§in iliÅŸkisel modeli kullanan ve SQL standart sorgu dilini destekleyen bir veritabanÄ± yÃ¶netim sistemidir. PostgreSQL aynÄ± zamanda iyi performans veren, gÃ¼venli ve geniÅŸ Ã¶zellikleri olan bir Veri TabanÄ± YÃ¶netim Sistemidir. â€¦ PostgreSQL Ã¼cretsiz ve aÃ§Ä±k kodludur. AnlatÄ±m ve Ã¶rnekleri denemek iÃ§in pgadmin3â€™Ã¼ yÃ¼klemeyi unutmayÄ±n. Kurulumu Ã§ok basit olduÄŸu iÃ§in o kÄ±smÄ± size bÄ±rakÄ±yorum ğŸ™‚

Normalizasyon

Normalizasyon(AyrÄ±ÅŸtÄ±rma) veritabanlarÄ±nda Ã§ok fazla sÃ¼tun ve satÄ±rdan oluÅŸan bir tabloyu tekrarlardan arÄ±ndÄ±rmak iÃ§in daha az satÄ±r ve sÃ¼tun iÃ§eren alt kÃ¼melerine ayrÄ±ÅŸtÄ±rma iÅŸlemidir. Normalizasyonun iki temel amacÄ± vardÄ±r. â€“Veri tabanÄ±nda veri tekrarlarÄ±nÄ± ortadan kaldÄ±rmak ve

â€“Veri tutarlÄ±lÄ±ÄŸÄ±nÄ± (Data Integrity) artÄ±rmak

Normalizasyon Ã§ok Ã¶nemli bir konudur.Hakan Ã–zakarâ€™Ä±n dediÄŸi gibi

Bakkal defteri ile veri tabanÄ± arasÄ±ndaki en temel fark: Normalizasyonâ€¦

Linki inceleyiniz : http://beltslib.net/veri-tabanlarinda-normalizasyon.html

AÅŸaÄŸÄ±daki baÅŸlÄ±klarÄ± inceleyelim

CREATE DROP ALTER TRUNCATE

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] ** **TABLE[ IF NOT EXISTS ] table_name ( [** **{ column_name data_type [ COLLATE collation ] [ column_constraint [ ... ] ] | table_constraint | LIKE parent_table [ like_option ... ] } [, ... ] ] ) Bir tane tablo oluÅŸturalÄ±m tbl_kisi adÄ±nda id ve ad tutacaÄŸÄ±mÄ±z bir tablo oluÅŸturduk serial diyerek otomatik artÄ±racak kendini ğŸ™‚

CREATE TABLE tbl_kisi( id SERIAL, ad VARCHAR(50) NOT NULL, ) tabloda tutacaÄŸÄ±mÄ±z Ã¶zellikleri artÄ±rabiliriz

CREATE TABLE tb_kisi ( id SERIAL, ad VARCHAR(50) NOT NULL, soyad VARCHAR(50) NOT NULL, dogum_tarihi DATE, email VARCHAR(70) NOT NULL, aktif BOOLEAN DEFAULT true NOT NULL, CONSTRAINT tb_kisi_email_key UNIQUE(email), CONSTRAINT tb_kisi_pkey PRIMARY KEY(id) )

DROP

DROP TABLE [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ] DROP TABLE veritabanÄ±ndan tablolarÄ± kaldÄ±rÄ±r. Bir tabloyu sadece sahibi kaldÄ±rabilir. Tabloyu kaldÄ±rmadan sadece satÄ±rlarÄ±nÄ± boÅŸaltmak istiyorsanÄ±z DELETE kullanÄ±n. DROP TABLE daima hedef tablonun iÃ§erdiÄŸi indeksleri, kurallarÄ±, tetikleri ve kÄ±sÄ±tlarÄ± kaldÄ±racaktÄ±r. Yine de, bir sanal tablo ya da baÅŸka bir tablodaki bir yabancÄ± anahtar tarafÄ±ndan baÅŸvurulan bir tabloyu kaldÄ±rabilmek iÃ§in CASCADE belirtilmelidir. (CASCADE baÄŸÄ±mlÄ± bir sanal tabloyu tamamen kaldÄ±racak, fakat yabancÄ± anahtar iÃ§in diÄŸer tablodan sadece yabancÄ± anahtar kÄ±sÄ±tÄ±nÄ± kaldÄ±racaktÄ±r.) isim

KaldÄ±rÄ±lacak tablonun ismi (ÅŸema nitelemeli olabilir). CASCADE

Tabloya baÄŸÄ±mlÄ± nesnelerin de (sanal tablolar gibi) silinmesini saÄŸlar. RESTRICT

Tabloya baÄŸÄ±mlÄ± nesneler varsa tablonun kaldÄ±rÄ±lmasÄ±nÄ± engeller. Bu Ã¶ntanÄ±mlÄ±dÄ±r. DROP TABLE tbl_kisi

Alter Table â€“ tabloda deÄŸiÅŸilik yaptÄ±rÄ±r

ALTER TABLE [ ONLY ] isim [ * ] eylem [, ... ] ALTER TABLE [ ONLY ] isim [ * ] RENAME [ COLUMN ] sÃ¼tun TO yeni_sÃ¼tun ALTER TABLE isim RENAME TO yeni_isim

eylem ÅŸunlardan biri olabilir:

** ADD [ COLUMN ] sÃ¼tun tÃ¼r [ sÃ¼tun_kÄ±sÄ±tÄ± [ ... ] ]** DROP [ COLUMN ] sÃ¼tun [ RESTRICT | CASCADE ] ALTER [ COLUMN ] sÃ¼tun TYPE tÃ¼r [ USING ifade ] ALTER [ COLUMN ] sÃ¼tun SET DEFAULT ifade ALTER [ COLUMN ] sÃ¼tun DROP DEFAULT ALTER [ COLUMN ] sÃ¼tun { SET | DROP } NOT NULL ALTER [ COLUMN ] sÃ¼tun SET STATISTICS tamsayÄ± ALTER [ COLUMN ] sÃ¼tun SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN } ADD tablo_kÄ±sÄ±tÄ± DROP CONSTRAINT kÄ±sÄ±t_ismi [ RESTRICT | CASCADE ] CLUSTER ON indeks_ismi SET WITHOUT CLUSTER SET WITHOUT OIDS OWNER TO yeni_aidiyet SET TABLESPACE tabloalanÄ±_ismi

ALTER TABLE distributors ADD COLUMN address varchar(30); --yeni column ekle ALTER TABLE distributors RENAME COLUMN address TO city; --column adÄ±nÄ± deÄŸiÅŸtir

*Truncate *

Tabloyu boÅŸaltÄ±r.Delete farkÄ± ne o zaman?? Delete yapÄ±ldÄ±ÄŸÄ±nda fiziksel tamamen bir silme olmaz flagleme yapar yeni satÄ±r eklendiÄŸinde bir sonraki idye ekler. Truncate siler drop+create iÅŸlemi yapar.

TRUNCATE [ TABLE ] [ ONLY ] name [ * ] [, ... ] [ RESTART IDENTITY | CONTINUE IDENTITY ] [ CASCADE | RESTRICT ]

Schema

Bir ÅŸema , tablolarÄ±n adlandÄ±rÄ±lmÄ±ÅŸ bir koleksiyonudur. DosyalarÄ± klasÃ¶rlemeye benzetebiliriz (sÃ¶z dizimi)

VeritabanÄ± . Åema . Tablo PostgreSQL deyimi CREATE SCHEMA bir ÅŸema oluÅŸturur.

CREATE SCHEMA myschema;

Veri Tipleri

Veri BÃ¼tÃ¼nlÃ¼ÄŸÃ¼ ve KÄ±sÄ±tlar

Constraints Check Constraints Not-Null Constraints ** *Unique Constraints * *Primary Keys * **Foreign Keys

Check Constraints --KontrolÃ¼ saÄŸlar, kÄ±sÄ±tlama belirleyebilir

CREATE TABLE products ( product_no integer, name text, price numeric CONSTRAINT positive_price CHECK (price > 0) );

Not-Null Constraints â€“boÅŸ bÄ±rakma

CREATE TABLE products ( product_no integer NOT NULL, name text NOT NULL, price numeric NOT NULL CHECK (price > 0) );

Unique Constraints â€“mail Ã¶rneÄŸi canlansÄ±n aynÄ± mailden kayÄ±ta izin yok

CREATE TABLE products ( product_no integer CONSTRAINT must_be_different UNIQUE, name text, price numeric);

Primary Keys â€“unique+notnull

CREATE TABLE products ( product_no integer PRIMARY KEY, name text, price numeric );

Foreign Keys

Hangi kolonun hangi topla ile iliÅŸkili olduÄŸunu saÄŸlamaya Ã§alÄ±ÅŸÄ±yor

CREATE TABLE products ( product_no integer PRIMARY KEY, name text, price numeric );

CREATE TABLE orders ( order_id integer PRIMARY KEY, shipping_address text, ... );

CREATE TABLE order_items ( product_no integer REFERENCES products, order_id integer REFERENCES orders, quantity integer, PRIMARY KEY (product_no, order_id) );

DDL (Data Definition Language)

Veri TanÄ±mlama Dili (DDL) deyimleri tablolarÄ±, veritabanÄ± yapÄ±sÄ±nÄ± veya ÅŸemalarÄ± tanÄ±mlamak iÃ§in kullanÄ±lÄ±r.

Bunlardan bazÄ±larÄ±;

â€“CREATE â€“ Veri tabanÄ±ndaki nesneleri oluÅŸturmak iÃ§in kullanÄ±lÄ±r.

â€“ALTER â€“ Veri tabanÄ± nesnelerinin yapÄ±sÄ±nÄ± deÄŸiÅŸtirmek iÃ§in kullanÄ±lÄ±r.

â€“DROP â€“ Veri tabanÄ±ndaki nesneleri silmek ya da baÅŸka bir ifadeyle ilgili nesneleri bÃ¼tÃ¼nÃ¼yle kaldÄ±rmak iÃ§in kullanÄ±lÄ±r.

â€“TRUNCATE â€“ KayÄ±tlar iÃ§in ayrÄ±lan tÃ¼m boÅŸluklar dahil, bir tablodaki tÃ¼m kayÄ±tlarÄ± kaldÄ±rÄ±lÄ±r

â€“COMMENT â€“ Veri sÃ¶zlÃ¼ÄŸÃ¼ne yorum eklemek iÃ§in kullanÄ±lÄ±r.

â€“RENAME â€“ Bir nesneyi yeniden adlandÄ±rmak iÃ§in kullanÄ±lÄ±r.

DCL (Data Control Language)

Veri Kontrol Dili (DCL) deyimleri yetkilendirme ya da ayrÄ±calÄ±klarÄ± belirlemek iÃ§in kullanÄ±lÄ±r.

Bunlardan bazÄ±larÄ±;

â€“GRANT â€“ Belirli bir kullanÄ±cÄ± ya da gruba veri tabanÄ±nÄ±n belirtilen nesnelerine eriÅŸim ayrÄ±calÄ±klarÄ±nÄ± verir.

â€“REVOKE â€“ GRANT komutu ile verilen ayrÄ±calÄ±klarÄ±n bir kÄ±smÄ±nÄ± ya da tÃ¼mÃ¼nÃ¼ geri almak iÃ§in kullanÄ±lÄ±r.

TCL (Transaction Control)

Ä°ÅŸlem Kontrol (TCL) deyimleri, DML ifadeleri tarafÄ±ndan yapÄ±lan deÄŸiÅŸiklikleri yÃ¶netmek iÃ§in kullanÄ±lÄ±r.

Bunlardan bazÄ±larÄ±;

â€“COMMIT â€“ YapÄ±lanlarÄ± kalÄ±cÄ± hale getirir. Ä°ÅŸin tamamlanmasÄ±nÄ± saÄŸlar.

â€“SAVEPOINT â€“ Daha sonra geri dÃ¶nÃ¼lecek bir dÃ¶nÃ¼ÅŸ noktasÄ± belirler.

â€“ROLLBACK â€“ Son COMMITâ€™e kadar olan yeri geri alÄ±r

DML â€“ Data Manipulation Language (Veri DÃ¼zenleme Dili)

INSERT â€“ ekleme UPDATE â€“ guncelleme DELETE â€“ silme INSERT INTO tablo_adi (sutun_1, sutun_2) VALUES (deger1, deger2) UPDATE tablo_adi SET yeni_bilgiler WHERE koÅŸullar DELETE FROM tablo_adi WHERE kosullar;

SQLâ€™e GiriÅŸ (Structured Query Language)

Select Insert Update Delete SELECT

SELECT * FROM tablo_ismi;

ALIAS KULLANMAK

AS ifedesi ile uzun ve kullanÄ±mÄ± zor olan tablo veya alan adlarÄ±na geÃ§ici olarak kÄ±sa isimler vererek bunlarÄ± kodlamalarÄ±mÄ±zda kullanabiliriz. BÃ¶ylece mevcut tablo yapÄ±mÄ±z bozmadan anlÄ±k olarak belirlediÄŸimiz isimleri kullanabiliriz.

select k.ad,k.soyad,k.dogum_yeri, from oim.tb_kisi as l ** **where k.id = 1 ; GROUP BY â€“ HAVING

GROUP BY fonksiyonu ile belli alanlara gÃ¶re gruplama yapÄ±lÄ±r.

SELECT select_list FROM ... [WHERE ...] GROUP BY grouping_column_reference [, grouping_column_reference]... select dogum_yeri, ad from oim.tb_kisi as k where k.dogum_yeri='Ankara' ** *group by 1,2 * **--YukarÄ±daki 1,2 dogum_yeri ve adÄ± temsil ediyor aÅŸaÄŸÄ±ya sorguyu uzun uzun yazmak yerine kolay HAVING yapÄ±sÄ± temelde WHERE ile aynÄ± gÃ¶revi yapmaktadÄ±r. GROUP BY ile kullanÄ±lÄ±r.

Where ifadesi ile belirtilen kriter Group By uygulanmadan Ã¶nce geÃ§erli olurken, Having ifadesi ile belirtilen kriter ise group by uygulandÄ±ktan sonra ortaya Ã§Ä±kan verileri filtrelemek iÃ§in kullanÄ±lÄ±r.

AyrÄ±ca Where ifadesinden sonra sum, avg gibi fonksiyonlar kullanÄ±lamazken, Having ile kullanÄ±labilir.

SELECT select_list FROM ... ** *[WHERE ...] * **GROUP BY ... HAVING boolean_expression select k.dogum_yeri,count (*) from oim.tb_kisi as k where k.dogum_yeri <> 'Ankara' group by 1 *having count() > 1 **

ORDER BY

ORDER BY ifadesi kayÄ±tlarÄ± belirtilen alanda, ASC (ascending) parametresi ile kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe, DESC (descending) parametresi ile bÃ¼yÃ¼kten kÃ¼Ã§Ã¼ÄŸe gÃ¶re sÄ±ralar. Burada sadece sayÄ±sal alanlar deÄŸil metinsel alanlarda alfabetik olarak sÄ±ralanabilir.

ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] SELECT * FROM Customers ORDER BY Country DESC;

BETWEEN

Between operatÃ¶rÃ¼ ile bir alanda belirtilen aralÄ±ktaki deÄŸerleri aramak iÃ§in kullanÄ±lÄ±r.

BETWEEN bir operatÃ¶rdÃ¼r ve WHERE ile kullanÄ±lÄ±r.

SELECT * FROM Products WHERE Price BETWEEN 10 AND 20;

IN/NOT IN

IN operatÃ¶rÃ¼ belirtilen tek bir alanda birden fazla deÄŸeri aramak iÃ§in kullanÄ±lÄ±r.

SELECT * FROM Customers WHERE City IN ('Paris','London');

LIMIT VE TOP

SELECT TOP 2 * FROM Musteri; // MÃ¼ÅŸteri tablosunun ilk 2 kaydÄ±nÄ± getirir. SELECT *** **FROM Personel LIMIT 5; // BaÅŸtan ilk 5 kaydÄ± Ã§eker. SELECT *** **FROM Personel LIMIT 10,5; // 10. kayÄ±ttan itibaren 5 kayÄ±t Ã§eker. // 11,12,13,14,15 inci sÄ±radaki kayÄ±tlar.

DISTINCT

DISTINCT ifadesi tablodaki belirtilen alanda bulunan kayÄ±tlardan birer Ã¶rnek alÄ±r. Yani tekrar eden kayÄ±tlardan bir tane alÄ±r ve bunun yanÄ±na da tekrar etmeyen kayÄ±tlarÄ± koyarak bir veri kÃ¼mesi oluÅŸturur.

SELECT DISTINCT (location) location, time, report FROM weather_reports ORDER BY location, time DESC;

Fonksiyonlar

Mathematical Functions abs,random,round Aggregate Functions count,sum,max String Functions lower, substring, trim Data Type Formatting Functions to_char, to_number Date/Time Functions now, extract, date_part Sequence Manipulation Functions nextval Array Functions array_to_string, array_length

Operatorler

Logical Operatorler(MantÄ±k OperatÃ¶rleri) AND, OR, NOT KarÅŸÄ±laÅŸtÄ±rma Operatorleri <, >, <=, =, != Matematiksel Operatorler +, -, *** **String Operatorleri Ã  || *Date/Time Operatorleri +, -, ** AÅŸaÄŸÄ±ya Ã¶ÄŸrendiklerinizi uygulamanÄ±z iÃ§in Ã¶rnekleri koyuyorum. Tek tek aÃ§Ä±klamasÄ±nÄ± yapmadÄ±m. UygulayÄ±p gÃ¶rÃ¼n ğŸ™‚

select * from oim.tb_ders ** *select * from oim.tb_ders_ogretmen * *select * from oim.tb_kisi_tipi * *select * from oim.tb_ogrenci_ders * **select * from oim.tb_kisi --YukarÄ±daki tablolarÄ± oluÅŸturun iÃ§inede veri ekleyerek denemelere baÅŸlayÄ±n :) select dogum_yeri from oim.tb_kisi as k where k.dogum_yeri='Ankara' AND k.ad='KEVSER' group by k.dogum_yeri,k.ad,k.soyad

select dogum_yeri, ad from oim.tb_kisi as k where k.dogum_yeri='Ankara' ** *group by 1,2 * **--YukarÄ±daki 1,2 dogum_yeri ve adÄ± temsil ediyor aÅŸaÄŸÄ±ya sorguyu uzun uzun yazmak yerine kolay

select dogum_yeri, count(*) from oim.tb_kisi as k where k.dogum_yeri='Ankara' ** **group by 1

select dogum_yeri, count(*) from oim.tb_kisi as k --where k.dogum_yeri='Ankara' ** **group by 1 --where sorgusunu kaldÄ±rdÄ±ÄŸÄ±mÄ±zda tÃ¼m illlerin kaÃ§ar tane olduÄŸunu gÃ¶rÃ¼rÃ¼z

select dogum_yeri, count(*) from oim.tb_kisi as k where k.dogum_yeri <> 'Ankara' -- esit deÄŸildir <> demek group by 1 having count(*)>1

--aÅŸaÄŸÄ±daki tarihten daha bÃ¼yÃ¼k Select k.dogum_tarihi From oim.tb_kisi k where k.dogum_tarihi>'1993-12-31'

Select k.* from oim.tb_kisi k where k.ad like 'Ahmet'

Select k.* from oim.tb_kisi k where k.ad like 'Ahmet%'

Select k.* from oim.tb_kisi k where k.ad ilike '%ahmet%' --ilek bÃ¼yÃ¼k kÃ¼Ã§Ã¼k karakter Ã¶nemsemezzz

Select k.soyad from oim.tb_kisi k where k.soyad not ilike '%a%' --soyadÄ±nda a geÃ§meyenlerr

Select k.dogum_tarihi from oim.tb_kisi k where k.dogum_tarihi>='1992-12-31' and k.dogum_tarihi<='1995-12-31'

veya betweenle yapÄ±mÄ±

where k.dogum_tarihi BETWEEN '1992-12-31' and '1995-12-31'

Select k.id from oim.tb_kisi k where k.id=6 or k.id=12 or k.id=16

veya

Select k.id from oim.tb_kisi k where k.id in (6,12,16)

Select k.* from oim.tb_kisi k where k.id in (6,12,16,17,18) order by k.ad,k.soyad --ada gÃ¶re sÄ±raladÄ±k

Select k.* from oim.tb_kisi k where k.id in (1,2,6,12,16,17,18) order by k.ad DESC,k.soyad --adÄ± tam tersi sÄ±ralandÄ±

Select k.* from oim.tb_kisi k order by k.dogum_tarihi, k.id DESC --dogum tarihini sÄ±rala idleri tam ters, sÄ±rala

Notlar:

Sql sorgularÄ±n bazÄ±larÄ± aÃ§Ä±klamalÄ± bazÄ±larÄ± aÃ§Ä±klamasÄ±z eÄŸer gerÃ§ek manada Ã¶ÄŸreneyim diyorsanÄ±z denemeler yapÄ±p bu deneme sonuÃ§larÄ±nÄ± kendiniz gÃ¶rmelisiniz ama anlaÅŸÄ±lmayan yerleri tabiki mail yoluyla yada yorum bÄ±rakarak sorabilirsiniz. Birinci bÃ¶lÃ¼mde en alta aÅŸaÄŸÄ±daki tablolarÄ± Ã§eken sorgularÄ± koymuÅŸtuk bunlara bir kÄ±sa aÃ§Ä±klama getiriyorum. Kurs esnasÄ±nda bir Ã¶rnek yapalÄ±m bu da oim(Ã¶ÄŸrenci isleri modulÃ¼) bizim schemamÄ±zÄ±n adÄ±ydÄ± sÃ¶z diziliminde bahsetmiÅŸtik veritabanÄ±.ÅŸema.tablo diye oradan kafanÄ±z karÄ±ÅŸmasÄ±n klasÃ¶rlemek gibi demiÅŸtik. Siz sorgulara gÃ¶re column ve veri ekleyebilirsiniz. Yada bir Ã¶rnek veri Ã¼zerinden benzer sorgularÄ± Ã§alÄ±ÅŸtÄ±rabilirsiniz. Kolay gelsin ğŸ™‚ select * from oim.tb_ders ** *select * from oim.tb_ders_ogretmen * *select * from oim.tb_kisi_tipi * *select * from oim.tb_ogrenci_ders * **select * from oim.tb_kisi

Åimdi devam ediyoruzâ€¦

Join

INNER JOÄ°N OUTER JOÄ°N CROSS-JOIN Join iÅŸlemleri hep kafamÄ± karÄ±ÅŸtÄ±rmÄ±ÅŸtÄ±r taki bu gÃ¶rsele kadar gÃ¶rdÃ¼m aydÄ±nlandÄ±m resmen ğŸ™‚ Ã–rneklerde anlayamadÄ±ÄŸÄ±nÄ±z durumlarda gÃ¶rsele tekrar tekrar bakÄ±n. SorgularÄ± deneyin veri seti bulamadÄ±ysanÄ±z -> https://www.w3schools.com/sql/sql_join.asp linkinde denemeleri gÃ¶rebilirsiniz..

join

Åimdi tek tek ele alalÄ±m ->

JOIN / INNER JOIN

SELECT column_name(s) FROM table1 INNER JOIN table2 ON table1.column_name=table2.column_name;

veya

SELECT column_name(s) FROM table1 JOIN table2 ON table1.column_name=table2.column_name; â€“tb_kisiâ€™de id olarak gÃ¶sterilen kisi tipinin karÅŸÄ±lÄ±ÄŸÄ±nÄ± gÃ¶sterdik

select k.ad,k.soyad,kt.tanim ** *from oim.tb_kisi k * *join oim.tb_kisi_tipi kt * **on k.kisi_tipi_id=kt.id *LEFT JOÄ°N â€“ RÄ°GHT JOÄ°N *

Left ve right joinlerde yukarÄ±daki gÃ¶rsele bakarsak daha iyi kavrarÄ±z. Yok rigth nasÄ±ldÄ± left nasÄ±ldÄ± dÃ¼ÅŸÃ¼nmeyin Ã¶ÄŸrenin LEFT JOÄ°Nâ€™i tablolarÄ± yazarken yer deÄŸiÅŸtirin olsun bitisin ğŸ™‚

SELECT column_name(s) FROM table1 LEFT JOIN table2 --RIGHT join iÃ§in left yerine right ON table1.column_name=table2.column_name;

veya

SELECT column_name(s) FROM table1 LEFT OUTER JOIN table2 --RIGHT join iÃ§in left yerine right ON table1.column_name=table2.column_name; SELECT Customers.CustomerName, Orders.OrderID FROM Customers JOIN Orders ON Customers.CustomerID=Orders.CustomerID ORDER BY Customers.CustomerName; â€“Ä°ki sorgu arasÄ±ndaki fark ne? JOÄ°N yaptÄ±ÄŸÄ±mÄ±zda ortak olanlar gelir ama LEFT de sol tarafÄ±n kapsadÄ±ÄŸÄ± ve ortaklar ama karÅŸÄ±lÄ±ÄŸÄ± olmayan sutunlar Ã§Ä±kar ve null atanÄ±r

SELECT Customers.CustomerName, Orders.OrderID FROM Customers LEFT JOIN Orders ON Customers.CustomerID=Orders.CustomerID ORDER BY Customers.CustomerName; FULL JOÄ°N

SELECT column_name(s) FROM table1 FULL OUTER JOIN table2 ON table1.column_name=table2.column_name;

SQL UNION KullanÄ±mÄ±

UNION ile iki adet tablomuzdaki seÃ§eceÄŸimiz alanlarÄ± birleÅŸtirerek tek bir tablo alanÄ±ymÄ±ÅŸ gibi kullanabiliriz. Union ile iki tablodaki alanlar birleÅŸtirilirken tekrarlayan kayÄ±tlar bir defa alÄ±nÄ±r. EÄŸer tekrarlayan kayÄ±tlarÄ±n alÄ±nmasÄ± isteniyorsa UNION ALL kullanÄ±lmalÄ±dÄ±r.

SELECT alan_ad(lari) FROM tablo1 UNION ALL SELECT alan_ad(lari) FROM tablo2 SELECT alan_ad(lari) FROM tablo1 UNION SELECT alan_ad(lari) FROM tablo2 not:

explain ->sorgunun yÃ¼rÃ¼tme planÄ±nÄ± gÃ¶sterir â€“> https://www.postgresql.org/docs/9.3/static/sql-explain.html

EXPLAIN [ ( option [, ...] ) ] statement EXPLAIN [ ANALYZE ] [ VERBOSE ] statement

where option can be one of:

**ANALYZE [ boolean ]**
**VERBOSE [ boolean ]**
**COSTS [ boolean ]**
**BUFFERS [ boolean ]**
**TIMING [ boolean ]**
**FORMAT { TEXT | XML | JSON | YAML }**
select * from oim.tb_ders_ogretmen dog join oim.tb_ders d on d.id=dog.ders_id

explain select * from oim.tb_ders_ogretmen dog join oim.tb_ders d on d.id=dog.ders_id ** **--Sorguyu yÃ¼rÃ¼tmez,Zaman gÃ¶stermez,Tahmini maliyet gÃ¶sterir. explain analyze select * from oim.tb_ders_ogretmen dog join oim.tb_ders d on d.id=dog.ders_id ** **--Sorguyu yÃ¼rÃ¼tÃ¼r,Zaman gÃ¶sterir.

not: SELECT INTO ifadesi ile bir tablodaki verileri alÄ±p yeni bir tablo oluÅŸturup iÃ§ine kopyalayabiliriz. SonuÃ§ta veritabanÄ±nda yeni bir tablo oluÅŸturulacaÄŸÄ± iÃ§in veritabanÄ± Ã¼zerinde iÅŸlem yapan kullanÄ±cÄ±nÄ±n yeni bir tablo oluÅŸturma yetkisine sahip olmasÄ± gerekmektedir.

SELECT alan_ad(lari) INTO yeni_tablo_adi [IN hedef_database] ** **FROM tablo1 Yeni oluÅŸturacaÄŸÄ±mÄ±z tablo aynÄ± veritabanÄ± iÃ§indeyse [IN hedef_database] ifadesi kullanÄ±lmaz. FarklÄ± bir veritabanÄ± iÃ§ine kopyasÄ±nÄ± alacaksak o zaman IN operatÃ¶rÃ¼ ile hedef veritabanÄ±nÄ± belirtmemiz gerekir.

Mevcut tablomuzdaki alanlar veri tipleri ve iÃ§indeki verilerle birlikte aynen kopyalanÄ±r. EÄŸer alan adÄ±nÄ± mevcut isminden farklÄ± bir isimle oluÅŸturmak istersek o zaman AS yapÄ±sÄ± kullanabiliriz.

SELECT id, ad_soyad AS isim, yasadigi_sehir AS sehir ** *INTO personel_yedek * **FROM personel CREATE [ OR REPLACE ] FUNCTION

CREATE [OR REPLACE] FUNCTION function_name (arguments) ** **RETURNS return_datatype AS $variable_name$ DECLARE declaration; [...] BEGIN < function_body > [...] RETURN { variable_name | value } END; LANGUAGE plpgsql; Ã–rnek

CREATE OR REPLACE FUNCTION totalRecords () RETURNS integer AS $total$ declare total integer; BEGIN SELECT count(*) into total FROM COMPANY; RETURN total; END; $total$ LANGUAGE plpgsql; CREATE FUNCTION oim.sp_ders_ortalama_hesapla(IN i_ders_ogretmen_id smallint) ** **RETURNS numeric AS $BODY$ declare l_sonuc numeric(4,2); begin select (sum(final)/count(*))::numeric(4,2) into l_sonuc from oim.tb_ogrenci_ders dog ** **where dog.ders_ogretmen_id=i_ders_ogretmen_id;

INSERT INTO oim.tb_ortalama(ders_ogretmen_id, ortalama) VALUES (i_ders_ogretmen_id, l_sonuc);

return l_sonuc; end;$BODY$ LANGUAGE plpgsql VOLATILE NOT LEAKPROOF;

Stored Procedure

PL / pgSQL PostgreSQL veritabanÄ± sistemi iÃ§in yÃ¼klenebilir bir prosedÃ¼rel dildir. FonksiyonlarÄ± ve trigger prosedÃ¼rlerini oluÅŸturmak iÃ§in kullanÄ±labilir SQL dili kontrol yapÄ±larÄ±nÄ± ekler KarmaÅŸÄ±k hesaplamalarÄ± yapabilir TÃ¼m kullanÄ±cÄ± tanÄ±mlÄ± tÃ¼rleri, iÅŸlevler ve operatÃ¶rleri devralÄ±r(inherit eder) Sunucu tarafÄ±ndan gÃ¼venilir olarak tanÄ±mlanabilir PL / PgSQL KullanmanÄ±n AvantajlarÄ±

SQL dilini, PostgreSQL ve diÄŸer birÃ§ok iliÅŸkisel veritabanlarÄ±nda sorgu dili olarak kullanabilmeyi saÄŸlar. TaÅŸÄ±nabilir ve Ã¶ÄŸrenmesi kolaydÄ±r. Fakat her SQL deyimi veritabanÄ± sunucusu tarafÄ±ndan ayrÄ± ayrÄ± yÃ¼rÃ¼tÃ¼lmelidir. (AyrÄ± bir transaction aÃ§ar ve ayrÄ± yÃ¼rÃ¼tÃ¼lÃ¼r.) Ä°Ã§ersinde program kontrol deyimleri, LOOP, WHILE, IF, EXIT ve geliÅŸmiÅŸ hata denetimi Ã¶zellikleri mevcuttur. Blok bazlÄ± yapÄ±dadÄ±r, kolay anlaÅŸÄ±lÄ±r ve yazÄ±lÄ±r. VeritabanÄ±na gÃ¶mÃ¼lÃ¼dÃ¼r ve onun parÃ§asÄ±dÄ±r VeritabanÄ±nÄ±n Ã§alÄ±ÅŸtÄ±ÄŸÄ± tÃ¼m platformlarda Ã§alÄ±ÅŸÄ±r. Platform baÄŸÄ±msÄ±zdÄ±r. VeritabanÄ±nÄ±n Ã¼zerinde Ã§alÄ±ÅŸtÄ±ÄŸÄ± iÃ§in network yÃ¼kÃ¼nÃ¼zÃ¼ azaltÄ±r. VeritabanÄ± Ã¼zerindeki tÃ¼m veri tipleri ile uyumluluk gÃ¶sterir. Oracle PL/SQL diline yazÄ±lÄ±m kurallarÄ± aÃ§Ä±sÄ±ndan Ã§ok benzer. Bu geÃ§iÅŸkenliÄŸi artÄ±rÄ±r. Bir PL/pgSQL fonksiyonu sonucunda tek bir deÄŸer dÃ¶nmek zorunda deÄŸildir. Birden fazla dÃ¶nÃ¼ÅŸ olacaksa output parametre tanÄ±mÄ± kullanÄ±lmalÄ±dÄ±r. Bunun dÄ±ÅŸÄ±nda fonksiyonlar,

Basit tipte bir veri dÃ¶nebilir; Record tipinde composit bir data dÃ¶nebilir; SonuÃ§ tablosunun pointerâ€™Ä± gibi tek bir instance dÃ¶nebilir. Hatta bazen hiÃ§ deÄŸer dÃ¶nmeyebilir. HiÃ§ bir deÄŸer dÃ¶nmÃ¼yor ise fonksiyonun sonunda sadece â€œreturnâ€ ya da â€œreturn voidâ€ denilebilir . PL / pgSQL YapÄ±sÄ±

Blok bazlÄ± yapÄ±dadÄ±r, kolay anlaÅŸÄ±lÄ±r ve yazÄ±lÄ±r. TanÄ±mlamasÄ± aÅŸaÄŸÄ±daki gibidir. DECLARE ** **Declarations (TanÄ±mlamalar) BEGIN Statements (Ã‡alÄ±ÅŸtÄ±rÄ±lacak Kodlar) END; BÃ¼tÃ¼n alt bloklar ENDâ€™ den Ã¶nce sonlanmalÄ±dÄ±r. Fonksiyon oluÅŸturmak iÃ§in gerekli olan tanÄ±mlama aÅŸaÄŸÄ±daki gibidir. CREATE [OR REPLACE] FUNCTION fonksiyon_adÄ± (parametre tipi) RETURNS dÃ¶nÃ¼s_turu AS $$degisken_Adi DECLARE tanÄ±mlamalar; BEGIN komutlar; ** **[RETURN] [Ã§Ä±ktÄ± deÄŸeri;] END; ** **$$ LANGUAGE plpgsql; Ã–RN:

CREATE FUNCTION topla(integer,integer) ** **RETURNS integer AS $$ DECLARE l_sonuc; BEGIN l_sonuc:= + ; RETURN l_sonuc; END; $$ LANGUAGE plpgsql; Fonksiyonu Ã§aÄŸÄ±rmak iÃ§in: SELECT fonksiyon_adi (parametre deÄŸerleri);

PERFORM fonksiyon_adi (parametre deÄŸerleri); Ä°pucu: PERFORM ile kullanÄ±mda fonksiyon bir deÄŸer dÃ¶ndÃ¼rmez.

Yorumlar (Comments)

Programlama dillerinin yorum yapÄ±sÄ±na benzemektedir. Bunun iÃ§in pl/pgsql de 2 yol vardÄ±r.

Tek satÄ±rlÄ± yorumlar

Ä°ki Ã§izgi ile (â€“) baÅŸlarlar, satÄ±r sonu karakteri barÄ±ndÄ±rmazlar. Blok yorumlar (Ã§ok satÄ±rlÄ± yorumlar)

Blok yorumlar /* ile baÅŸlarlar ve birden fazla satÄ±r iÃ§erirler. */ ile biter.

DeÄŸiÅŸkenler (Variables)

CONSTANT anahtar kelimesi sabit deÄŸer belirtir. NOT NULL anahtar kelimesi deÄŸiÅŸkenin NULL olamayacaÄŸÄ±nÄ± belirtir. DEFAULT anahtar kelimesi deÄŸiÅŸkene Ã¶n tanÄ±mlÄ± bir deÄŸer atar. DECLARE DeÄŸiÅŸken_adÄ± [ CONSTANT ] veri_tipi [NOT NULL] [{ DEFAULT | := } deÄŸer ]; BEGIN Ã–RN:

quantity integer DEFAULT 63; url varchar := 'http://mvrprime.com'; user_id CONSTANT integer := 17;

Fonksiyon Parametreleri (Function Parameters)

IN OUT INOUT VARIADIC InOut Parametre tipi, Hem veri giriÅŸi hem veri Ã§Ä±kÄ±ÅŸÄ±nda kullanÄ±lÄ±r. DeÄŸeri alt program iÃ§erisinde set edilebilir ve program sonlandÄ±ÄŸÄ±nda sahip olduÄŸu son deÄŸeri dÄ±ÅŸarÄ±ya dÃ¶ndÃ¼rÃ¼r.

Ã–RN:

CREATE OR REPLACE FUNCTION kare(INOUT integer a) AS $$ BEGIN a:= $a + $a; END; VARIADIC parametre tipi, AynÄ± veri tÃ¼rÃ¼ne sahip tÃ¼m argÃ¼manlarÄ± bir dizi (array) olarak fonksiyonda kullanmaya yarar.

SQL SELECT INTO KullanÄ±mÄ±

Select sorgusu neticesinde elde edilen sonuÃ§ row tipinde deÄŸiÅŸkene, recordâ€™a veya birden fazla deÄŸiÅŸkene(virgÃ¼lle ayrÄ±lmÄ±ÅŸ listeye) atanabilir. KullanÄ±mÄ±:

SELECT select_ifadeleri INTO [STRICT] target FROM ...; Ã–RN:

DECLARE kayit RECORD; BEGIN SELECT INTO kayit * FROM kullanici WHERE kullanici_id = 7; IF kayit.homepage IS NULL THEN RETURN 'https://kevserkose.wordpress.com/'; END IF; END; Burda yazdÄ±klarÄ±m size sadece bir pencere aÃ§ar deneyip Ã¶rnekler Ã§Ã¶zmek anlamanÄ±zÄ± saÄŸlar.

AyrÄ±ntÄ± iÃ§in https://www.postgresql.org/docs/9.2/static/plpgsql.html

VÄ°EW

Viewler saklanmÄ±ÅŸ sorgular olarak adlandÄ±rÄ±labilirler. Sanal tablolardÄ±r fiziksel olarak yokturlar. Her Ã§aÄŸrÄ±ldÄ±klarÄ±nda sorgu tekrar Ã§alÄ±ÅŸÄ±r. BirÃ§ok amaÃ§ iÃ§in kullanmak mÃ¼mkÃ¼ndÃ¼r. KarmaÅŸÄ±k veritabanlarÄ±nda verilere daha rahat ulaÅŸmak Sanalda olsa bir Normalizasyon yapmak iÃ§in kullanÄ±la bilirler. View oluÅŸturma iÃ§in CREATE VIEW konutu kullanÄ±lÄ±r.

KULLANIMI

CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] VIEW name [ ( column_name [, ...] ) ] [ WITH ( view_option_name [= view_option_value] [, ... ] ) ] ** **AS query [ WITH [ CASCADED | LOCAL ] CHECK OPTION ] CREATE VIEW public.view1 ( ** *) * *AS * **SELECT ;--yapÄ±lmasÄ± istediÄŸiniz query yazÄ±lÄ±r view kullanÄ±mÄ± gÃ¼zel ve iÅŸlevlidir :) Ã–RN.

CREATE VIEW oim.vw_ogrenci AS SELECT 'Ahmet DENÄ°Z';

CREATE VIEW oim.vw_ogrenci AS SELECT 'AHMET DENÄ°Z'::Varchar(20) AS ogrenci;

Select * from oim.vw_ogrenci CREATE OR REPLACE VIEW oim.vw_kisi ( id, kisi_tipi_id, ad, soyad, dogum_tarihi, dogum_yeri, kisi_tipi ) AS SELECT k.id, k.kisi_tipi_id, k.ad, k.soyad, k.dogum_tarihi, k.dogum_yeri, kt.tanim FROM oim.tb_kisi k ** **join oim.tb_kisi_tipi kt on kt.id = k.kisi_tipi_id Ã–RN:

CREATE VIEW oim.vw_ogrenci_dersler as SELECT k.id, kt.tanim kis_tipi, k.ad, k.soyad, k.dogum_tarihi, k.dogum_yeri, d.ders_adi, d.ders_saati, od.final, od.vize, og.acildigi_tarih, ** **ko.ad || ' '|| ko.soyad as ogretmen FROM oim.tb_kisi k join oim.tb_kisi_tipi kt on kt.id = k.kisi_tipi_id join oim.tb_ogrenci_ders od on od.kisi_id = k.id join oim.tb_ders_ogretmen og on og.id = od.ders_ogretmen_id join oim.tb_kisi ko on ko.id = og.kisi_id join oim.tb_ders d on d.id = og.ders_id

MATERIALIZED VIEW OLUÅTURMAK

Nedir bu materialized view?? CREATE MATERYALIZED VIEW , sorgunun somutlaÅŸtÄ±rÄ±lmÄ±ÅŸ bir gÃ¶rÃ¼nÃ¼mÃ¼nÃ¼ tanÄ±mlar. Sorgu yÃ¼rÃ¼tÃ¼ldÃ¼ÄŸÃ¼nde ve komutun verildiÄŸi anda ( WITH NO DATA kullanÄ±lmadÄ±ÄŸÄ±nda) gÃ¶rÃ¼nÃ¼mÃ¼ doldurmak iÃ§in kullanÄ±lÄ±r ve daha sonra REFRESH MATERIALIZED VIEW kullanÄ±larak yenilenebilir .

CREATE MATERIALIZED VIEW ** **CREATE MATERIALIZED VIEW oim.vw_ogrenci_dersler_sabit as SELECT k.id, kt.tanim kis_tipi, k.ad, k.soyad, k.dogum_tarihi, k.dogum_yeri, d.ders_adi, d.ders_saati, od.final, od.vize, og.acildigi_tarih, ** **ko.ad || ' '|| ko.soyad as ogretmen --Burda yapÄ±lan iki string columnu birleÅŸtirir ogretmen altÄ±nda FROM oim.tb_kisi k join oim.tb_kisi_tipi kt on kt.id = k.kisi_tipi_id join oim.tb_ogrenci_ders od on od.kisi_id = k.id join oim.tb_ders_ogretmen og on og.id = od.ders_ogretmen_id join oim.tb_kisi ko on ko.id = og.kisi_id join oim.tb_ders d on d.id = og.ders_id Select * from oim.vw_ogrenci_dersler_sabit Select * from oim.vw_ogrenci_dersler REFRESH MATERIALIZED VIEW oim.vw_ogrenci_dersler_sabit; Konularla ilgili Ã¶rnekler /* Ã¶rnekler sonundaki nota dikkar ğŸ™‚ */

Select * from oim.tb_kisi k *JOIN oim.tb_ogrenci_ders ogr_ders ON ogr_ders.id=k.id *

Select o.*,k.ad,k.soyad from oim.tb_ogrenci_ders o JOIN oim.tb_ders_ogretmen a ON a.id = o.ders_ogretmen_id JOIN oim.tb_kisi k ON k.id=a.kisi_id

Select o.*,k.ad,k.soyad,k.kisi_tipi_id from oim.tb_ogrenci_ders o JOIN oim.tb_ders_ogretmen a ON a.id = o.ders_ogretmen_id JOIN oim.tb_kisi k ON k.id=a.kisi_id JOIN oim.tb_kisi_tipi kt ON k.kisi_tipi_id =kt.id where kt.id=1 --kt.tanim='ogretmen'

SELECT * from oim.tb_kisi k JOIN oim.tb_kisi_tipi kt ON k.kisi_tipi_id =kt.id where kt.id=1

*--ogrenciderslerden ogrenciye baÄŸla kisiid uzerinden *

select * from oim.tb_ogrenci_ders a JOIN oim.tb_kisi k ON k.id=a.id where a.vize<=50

select * from oim.tb_ogrenci_ders a JOIN oim.tb_kisi k ON k.id=a.id where (a.vize+a.final)/2<=50

SELECT k.ad,k.soyad,kt.tanim from oim.tb_kisi_tipi kt JOIN oim.tb_kisi k ON kt.id=k.kisi_tipi_id

not:explain query Ã§alÄ±ÅŸtÄ±rma ÅŸekli var sayfalar arasÄ±ndaki joinleri gÃ¶steriyor. ** **Bu kamut yardÄ±mÄ±yla iyileÅŸtirmeler yapÄ±labilir

select * from oim.tb_ders_ogretmen dog join oim.tb_ders d on d.id=dog.ders_id

explain select * from oim.tb_ders_ogretmen dog join oim.tb_ders d on d.id=dog.ders_id

explain analyze select * from oim.tb_ders_ogretmen dog join oim.tb_ders d on d.id=dog.ders_id

CREATE OR REPLACE FUNCTION oim.sp_carpma(i_birinci bigint, i_ikinci bigint)

RETURNS bigint AS *$BODY$begin *

return i_birinci*i_ikinci;

end;$BODY$

LANGUAGE plpgsql VOLATILE COST 100;

ALTER FUNCTION oim.sp_carpma(bigint, bigint) OWNER TO postgres;

select oim.sp_carpma(4,5) --bu ÅŸekilde fonk parametre gÃ¶nderdik

select sum(final), count() from oim.tb_ogrenci_ders dog * **where dog.ders_ogretmen_id=1

--finalleri toplayÄ±p topladÄ±ÄŸÄ± kadar ogrenci sayÄ±sÄ±nÄ± veriyor

select sum(final), count(), sum(final)/count() as ortalama from oim.tb_ogrenci_ders dog ** **where dog.ders_ogretmen_id=1

select sum(final), count(), (sum(final)/count())::numeric(4,2) as ortalama from oim.tb_ogrenci_ders dog ** **where dog.ders_ogretmen_id=1

CREATE FUNCTION oim.sp_ders_ortalama_hesapla(IN i_ders_ogretmen_id smallint) RETURNS numeric AS *$BODY$declare *

l_sonuc numeric(4,2);

begin

select (sum(final)/count(*))::numeric(4,2) into l_sonuc from oim.tb_ogrenci_ders dog ** **where dog.ders_ogretmen_id=i_ders_ogretmen_id;

INSERT INTO oim.tb_ortalama( ders_ogretmen_id, ortalama) VALUES (i_ders_ogretmen_id, l_sonuc);

return l_sonuc;

end;$BODY$ LANGUAGE plpgsql VOLATILE NOT LEAKPROOF;

--yeni ogrenci gelebilir yada herhangi bir durumunda deÄŸiÅŸen gÃ¼ncellemelere gÃ¶re trigger yazma

CREATE FUNCTION oim.sp_ders_ortalama_guncelle() RETURNS trigger AS $BODY$begin ** *if (TG_OP = 'DELETE') then * **perform oim.sp_ders_ortalama_hesapla(old.ders_ogretmen_id); return OLD; elsif (TG_OP='UPDATE') THEN ** **perform oim.sp_ders_ortalama_hesapla(new.ders_ogretmen_id); return NEW; elsif(TG_OP='INSERT') THEN perform oim.sp_ders_ortalama_hesapla(new.ders_ogretmen_id); RETURN NEW; END IF; RETURN NULL; END;$BODY$ LANGUAGE plpgsql VOLATILE NOT LEAKPROOF;

CREATE TRIGGER trg_ders_ortalama_guncelle

AFTER INSERT OR UPDATE OR DELETE

ON oim.tb_ogrenci_ders

FOR EACH ROW EXECUTE PROCEDURE oim.sp_ders_ortalama_guncelle();

test edelim ortalama tablosunda deÄŸiÅŸiklik yapÄ±lÄ±nca tablo yeni ortalama verecek mi??

UPDATE oim.tb_ogrenci_ders SET final=98 WHERE id=1; --gÃ¼ncellledik

*select * from oim.tb_ortalama --yeni ortalama *

view

CREATE VIEW oim.vw_kisi ** *AS * *SELECT k.,kt.tanim from oim.tb_kisi k join oim.tb_kisi_tipi kt on kt.id=k.kisi_tipi_id;

CREATE OR REPLACE VIEW oim.vw_kisi( --replace dÃ¼zenlemeye yarar varsa duzenlee id, kisi_tipi_id, ad, soyad, dogum_tarihi, dogum_yeri, tanim) AS SELECT k.id, k.kisi_tipi_id, k.ad, k.soyad, k.dogum_tarihi, k.dogum_yeri, kt.tanim FROM oim.tb_kisi k JOIN oim.tb_kisi_tipi kt ON kt.id = k.kisi_tipi_id;

a.ad || ' ' || a.soyad as ogretmen -- iki sutunu birleÅŸtirip bir sutunda gÃ¶stermek join oim.tb_kisi a on a.id=og.kisi_id

NotlarÄ±n sonuna ÅŸÃ¼kÃ¼rler olsun geldik.Yasin TATAR, Ahmet FÄ°NCAN, Fatih ALA AB2017 PostgreSQL-101 hocalarÄ±mÄ±za Ã§ok teÅŸekkÃ¼r ediyorum. Benim aklÄ±mda hem efendikleri hemde bilgileriyle kaldÄ±lar. DÃ¶rt gÃ¼nlÃ¼k sÃ¼reÃ§ gerÃ§ekten dolu dolu geÃ§ti. Ä°nÅŸAllah yollarÄ±mÄ±zÄ± tekrar kesiÅŸir ğŸ™‚

Sevgili postgresciler sevgiyle kalÄ±n ğŸ™‚
